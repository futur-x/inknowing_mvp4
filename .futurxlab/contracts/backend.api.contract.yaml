# InKnowing MVP 4.0 - Backend API Contract
# Contract-Driven Development (CDD) - 后端API契约
# Version: 1.0.0
# Generated: 2025-09-21
# Purpose: Define and enforce backend API standards

contract:
  version: "1.0.0"
  name: "InKnowing Backend API"
  type: "backend-api"

# ================================
# 1. API Configuration
# ================================
api_config:
  base_path: "/v1"
  version: "1.0.0"
  protocol: "HTTP/1.1"
  content_type: "application/json"

  server:
    development:
      host: "localhost"
      port: 8888
      url: "http://localhost:8888"

    production:
      host: "api.inknowing.com"
      port: 443
      url: "https://api.inknowing.com"

# ================================
# 2. Authentication Configuration
# ================================
authentication:
  type: "bearer_token"
  header: "Authorization"
  format: "Bearer {token}"
  endpoints:
    all_protected_routes:
      require: "valid_jwt_token"
      response_401: "token_invalid_or_expired"

# ================================
# 3. Authentication Endpoints
# ================================
endpoints:
  auth:
    register:
      method: "POST"
      path: "/auth/register"
      request:
        body:
          username: "string, required, 3-50 chars"
          password: "string, required, 8+ chars"
          phone: "string, optional"
          email: "string, optional"
      response:
        success:
          status: 201
          body:
            user: "User object"
            access_token: "string (JWT)"
            refresh_token: "string (JWT)"
            ws_token: "string (JWT for WebSocket)"
        errors:
          400: "Invalid input data"
          409: "User already exists"

    login:
      method: "POST"
      path: "/auth/login"
      request:
        body:
          username: "string, required"
          password: "string, required"
      response:
        success:
          status: 200
          body:
            user: "User object"
            access_token: "string (JWT)"
            refresh_token: "string (JWT)"
            ws_token: "string (JWT for WebSocket)"
        errors:
          401: "Invalid credentials"
          404: "User not found"

    logout:
      method: "POST"
      path: "/auth/logout"
      authentication: "required"
      response:
        success:
          status: 200
          body:
            message: "Logged out successfully"

    refresh:
      method: "POST"
      path: "/auth/refresh"
      request:
        body:
          refresh_token: "string, required"
      response:
        success:
          status: 200
          body:
            access_token: "string (JWT)"
            refresh_token: "string (JWT)"
        errors:
          401: "Invalid or expired refresh token"

    verify_code:
      method: "POST"
      path: "/auth/verify-code"
      request:
        body:
          phone: "string, required"
          code: "string, required, 6 digits"
      response:
        success:
          status: 200
          body:
            verified: "boolean"
        errors:
          400: "Invalid code"
          404: "Code not found or expired"

# ================================
# 4. User Endpoints
# ================================
  users:
    profile:
      method: "GET"
      path: "/users/profile"
      authentication: "required"
      response:
        success:
          status: 200
          body:
            id: "uuid"
            username: "string"
            phone: "string"
            email: "string"
            nickname: "string"
            avatar: "string"
            bio: "string"
            membership_type: "enum[free,basic,premium,super]"
            created_at: "datetime"

    update_profile:
      method: "PATCH"
      path: "/users/profile"
      authentication: "required"
      request:
        body:
          nickname: "string, optional"
          avatar: "string, optional"
          bio: "string, optional"
          email: "string, optional"
      response:
        success:
          status: 200
          body: "Updated user profile"

    membership:
      method: "GET"
      path: "/users/membership"
      authentication: "required"
      response:
        success:
          status: 200
          body:
            type: "enum[free,basic,premium,super]"
            status: "enum[active,expired,cancelled]"
            expires_at: "datetime"
            dialogue_quota: "integer"
            used_quota: "integer"

    upgrade_membership:
      method: "POST"
      path: "/users/membership/upgrade"
      authentication: "required"
      request:
        body:
          plan_type: "enum[basic,premium,super]"
          payment_method: "enum[wechat,alipay,stripe]"
      response:
        success:
          status: 200
          body:
            order_id: "string"
            payment_url: "string"

    quota:
      method: "GET"
      path: "/users/quota"
      authentication: "required"
      response:
        success:
          status: 200
          body:
            total: "integer"
            used: "integer"
            remaining: "integer"
            reset_date: "datetime"

# ================================
# 4. Book Endpoints
# ================================
  books:
    list:
      method: "GET"
      path: "/books"
      query_params:
        page: "integer, default=1"
        limit: "integer, default=20, max=100"
        sort: "enum[popular,newest,rating]"
        category: "string, optional"
      response:
        success:
          status: 200
          body:
            items: "Book[] array"
            total: "integer"
            page: "integer"
            pages: "integer"

    popular:
      method: "GET"
      path: "/books/popular"
      query_params:
        limit: "integer, default=10"
      response:
        success:
          status: 200
          body:
            items: "Book[] array"

    detail:
      method: "GET"
      path: "/books/{id}"
      path_params:
        id: "uuid, required"
      response:
        success:
          status: 200
          body:
            id: "uuid"
            title: "string"
            author: "string"
            description: "string"
            cover_image: "string"
            category: "string"
            tags: "string[]"
            rating: "float"
            dialogue_count: "integer"
        errors:
          404: "Book not found"

    characters:
      method: "GET"
      path: "/books/{id}/characters"
      path_params:
        id: "uuid, required"
      response:
        success:
          status: 200
          body:
            items: "Character[] array"
        errors:
          404: "Book not found"

# ================================
# 5. Search Endpoints
# ================================
  search:
    question_search:
      method: "GET"
      path: "/search"
      query_params:
        q: "string, required"
        limit: "integer, default=10"
        type: "enum[semantic,keyword]"
      response:
        success:
          status: 200
          body:
            results: "SearchResult[] array"
            total: "integer"

    book_search:
      method: "GET"
      path: "/search/books"
      query_params:
        q: "string, required"
        category: "string, optional"
        author: "string, optional"
      response:
        success:
          status: 200
          body:
            results: "Book[] array"
            total: "integer"

# ================================
# 6. Dialogue Endpoints
# ================================
  dialogue:
    start_book_dialogue:
      method: "POST"
      path: "/dialogues/book/start"
      authentication: "required"
      request:
        body:
          book_id: "uuid, required"
          initial_message: "string, optional"
      response:
        success:
          status: 201
          body:
            session_id: "uuid"
            book: "Book object"
            context: "string"
            ws_url: "string"

    start_character_dialogue:
      method: "POST"
      path: "/dialogues/character/start"
      authentication: "required"
      request:
        body:
          character_id: "uuid, required"
          book_id: "uuid, required"
          initial_message: "string, optional"
      response:
        success:
          status: 201
          body:
            session_id: "uuid"
            character: "Character object"
            context: "string"
            ws_url: "string"

    send_message:
      method: "POST"
      path: "/dialogues/{id}/messages"
      authentication: "required"
      path_params:
        id: "uuid, session_id"
      request:
        body:
          content: "string, required"
          type: "enum[text,voice], default=text"
      response:
        success:
          status: 200
          body:
            message_id: "uuid"
            response: "string (AI response)"

    get_messages:
      method: "GET"
      path: "/dialogues/{id}/messages"
      authentication: "required"
      path_params:
        id: "uuid, session_id"
      query_params:
        page: "integer, default=1"
        limit: "integer, default=50"
      response:
        success:
          status: 200
          body:
            messages: "Message[] array"
            total: "integer"

    get_context:
      method: "GET"
      path: "/dialogues/{id}/context"
      authentication: "required"
      path_params:
        id: "uuid, session_id"
      response:
        success:
          status: 200
          body:
            context: "string"
            book_info: "object"
            character_info: "object, optional"

    history:
      method: "GET"
      path: "/dialogues/history"
      authentication: "required"
      query_params:
        page: "integer, default=1"
        limit: "integer, default=20"
      response:
        success:
          status: 200
          body:
            sessions: "DialogueSession[] array"
            total: "integer"

# ================================
# 7. Upload Endpoints
# ================================
  uploads:
    check:
      method: "POST"
      path: "/uploads/check"
      authentication: "required"
      request:
        body:
          filename: "string"
          file_hash: "string"
      response:
        success:
          status: 200
          body:
            exists: "boolean"
            upload_id: "string, if exists"

    upload:
      method: "POST"
      path: "/uploads"
      authentication: "required"
      request:
        content_type: "multipart/form-data"
        body:
          file: "file, required"
          title: "string, required"
          author: "string, required"
          description: "string, optional"
      response:
        success:
          status: 201
          body:
            upload_id: "uuid"
            status: "enum[processing,completed,failed]"

    status:
      method: "GET"
      path: "/uploads/{id}"
      authentication: "required"
      path_params:
        id: "uuid, upload_id"
      response:
        success:
          status: 200
          body:
            status: "enum[processing,completed,failed]"
            progress: "integer (0-100)"
            book_id: "uuid, if completed"
            error: "string, if failed"

    user_uploads:
      method: "GET"
      path: "/uploads/my"
      authentication: "required"
      response:
        success:
          status: 200
          body:
            uploads: "Upload[] array"

# ================================
# 8. WebSocket Endpoints
# ================================
  websocket:
    dialogue:
      path: "/ws/dialogue/{session_id}"
      protocol: "WebSocket"
      authentication: "Bearer token in query or cookie"
      messages:
        client_to_server:
          type: "message"
          payload:
            content: "string"
            timestamp: "datetime"

        server_to_client:
          - type: "message"
            payload:
              content: "string"
              role: "enum[assistant,user]"
              timestamp: "datetime"

          - type: "stream_chunk"
            payload:
              chunk: "string"
              done: "boolean"

          - type: "error"
            payload:
              code: "string"
              message: "string"

          - type: "connection"
            payload:
              status: "enum[connected,disconnected]"

# ================================
# 9. Payment Endpoints
# ================================
  payment:
    wechat_callback:
      method: "POST"
      path: "/payment/callback/wechat"
      request:
        body: "WeChat payment notification"
      response:
        success:
          status: 200
          body: "XML response"

    alipay_callback:
      method: "POST"
      path: "/payment/callback/alipay"
      request:
        body: "Alipay payment notification"
      response:
        success:
          status: 200
          body: "success"

    order_status:
      method: "GET"
      path: "/payment/orders/{id}"
      authentication: "required"
      path_params:
        id: "string, order_id"
      response:
        success:
          status: 200
          body:
            order_id: "string"
            status: "enum[pending,paid,failed,refunded]"
            amount: "decimal"
            created_at: "datetime"

# ================================
# 10. Admin Endpoints
# ================================
  admin:
    auth:
      login:
        method: "POST"
        path: "/admin/auth/login"
        request:
          body:
            username: "string, required"
            password: "string, required"
        response:
          success:
            status: 200
            body:
              admin: "Admin object"
              access_token: "string (JWT)"
              refresh_token: "string (JWT)"

      logout:
        method: "POST"
        path: "/admin/auth/logout"
        authentication: "admin_required"
        response:
          success:
            status: 200

      refresh:
        method: "POST"
        path: "/admin/auth/refresh"
        request:
          body:
            refresh_token: "string, required"
        response:
          success:
            status: 200
            body:
              access_token: "string (JWT)"

    dashboard:
      stats:
        method: "GET"
        path: "/admin/dashboard/stats"
        authentication: "admin_required"
        response:
          success:
            status: 200
            body:
              user_stats: "object"
              dialogue_stats: "object"
              book_stats: "object"
              system_stats: "object"

    users:
      list:
        method: "GET"
        path: "/admin/users"
        authentication: "admin_required"
        query_params:
          page: "integer, default=1"
          limit: "integer, default=20"
          search: "string, optional"
          membership: "string, optional"
          status: "string, optional"
        response:
          success:
            status: 200
            body:
              items: "User[] array"
              total: "integer"

      get:
        method: "GET"
        path: "/admin/users/{id}"
        authentication: "admin_required"
        path_params:
          id: "uuid, required"
        response:
          success:
            status: 200
            body: "User object"

      update:
        method: "PATCH"
        path: "/admin/users/{id}"
        authentication: "admin_required"
        path_params:
          id: "uuid, required"
        request:
          body:
            status: "string, optional"
            membership_type: "string, optional"
        response:
          success:
            status: 200

    books:
      list:
        method: "GET"
        path: "/admin/books"
        authentication: "admin_required"
        query_params:
          page: "integer, default=1"
          limit: "integer, default=20"
          status: "string, optional"
        response:
          success:
            status: 200
            body:
              items: "Book[] array"
              total: "integer"

      create:
        method: "POST"
        path: "/admin/books"
        authentication: "admin_required"
        request:
          body:
            title: "string, required"
            author: "string, required"
            description: "string, optional"
        response:
          success:
            status: 201
            body: "Book object"

      update:
        method: "PATCH"
        path: "/admin/books/{id}"
        authentication: "admin_required"
        path_params:
          id: "uuid, required"
        request:
          body:
            title: "string, optional"
            status: "string, optional"
        response:
          success:
            status: 200

      delete:
        method: "DELETE"
        path: "/admin/books/{id}"
        authentication: "admin_required"
        path_params:
          id: "uuid, required"
        response:
          success:
            status: 204

# ================================
# 11. Admin AI Model Endpoints
# ================================
  admin_ai_models:
    list:
      method: "GET"
      path: "/admin/ai-models"
      authentication: "admin_required"
      response:
        success:
          status: 200
          body:
            models: "ModelConfig[] array"

    get:
      method: "GET"
      path: "/admin/ai-models/{id}"
      authentication: "admin_required"
      path_params:
        id: "string, model_id"
      response:
        success:
          status: 200
          body: "ModelConfig object"

    update:
      method: "PATCH"
      path: "/admin/ai-models/{id}"
      authentication: "admin_required"
      path_params:
        id: "string, model_id"
      request:
        body:
          parameters: "object"
          is_active: "boolean"
      response:
        success:
          status: 200

    test:
      method: "POST"
      path: "/admin/ai-models/{id}/test"
      authentication: "admin_required"
      path_params:
        id: "string, model_id"
      request:
        body:
          test_input: "string"
      response:
        success:
          status: 200
          body:
            result: "string"
            latency: "float"

# ================================
# 12. Admin Dialogue Management
# ================================
  admin_dialogues:
    list:
      method: "GET"
      path: "/admin/dialogues"
      authentication: "admin_required"
      query_params:
        page: "integer, default=1"
        limit: "integer, default=20"
        user_id: "uuid, optional"
        book_id: "uuid, optional"
        status: "string, optional"
      response:
        success:
          status: 200
          body:
            items: "DialogueSession[] array"
            total: "integer"

    get:
      method: "GET"
      path: "/admin/dialogues/{id}"
      authentication: "admin_required"
      path_params:
        id: "uuid, session_id"
      response:
        success:
          status: 200
          body: "DialogueSession with messages"

    terminate:
      method: "POST"
      path: "/admin/dialogues/{id}/terminate"
      authentication: "admin_required"
      path_params:
        id: "uuid, session_id"
      response:
        success:
          status: 200

# ================================
# 13. Admin Analytics
# ================================
  admin_analytics:
    user_activity:
      method: "GET"
      path: "/admin/analytics/user-activity"
      authentication: "admin_required"
      query_params:
        period: "enum[day,week,month], default=week"
        group_by: "enum[hour,day,week], default=day"
      response:
        success:
          status: 200
          body:
            data: "array of activity data"

    dialogue_stats:
      method: "GET"
      path: "/admin/analytics/dialogue-stats"
      authentication: "admin_required"
      query_params:
        period: "enum[day,week,month], default=week"
      response:
        success:
          status: 200
          body:
            total: "integer"
            by_book: "object"
            by_user: "object"

    cost_analysis:
      method: "GET"
      path: "/admin/analytics/costs"
      authentication: "admin_required"
      query_params:
        period: "enum[day,week,month], default=month"
      response:
        success:
          status: 200
          body:
            total_cost: "float"
            by_model: "object"
            by_user: "object"

# ================================
# 14. Admin Monitoring
# ================================
  admin_monitoring:
    system_status:
      method: "GET"
      path: "/admin/monitoring/system"
      authentication: "admin_required"
      response:
        success:
          status: 200
          body:
            status: "enum[healthy,degraded,critical]"
            components: "object"

    error_logs:
      method: "GET"
      path: "/admin/monitoring/errors"
      authentication: "admin_required"
      query_params:
        severity: "enum[error,warning,info], optional"
        page: "integer, default=1"
        limit: "integer, default=50"
      response:
        success:
          status: 200
          body:
            items: "ErrorLog[] array"
            total: "integer"

    performance_metrics:
      method: "GET"
      path: "/admin/monitoring/performance"
      authentication: "admin_required"
      query_params:
        metric: "enum[latency,throughput,error_rate]"
        period: "enum[hour,day,week], default=day"
      response:
        success:
          status: 200
          body:
            data: "array of metric data"

    alerts:
      method: "GET"
      path: "/admin/monitoring/alerts"
      authentication: "admin_required"
      query_params:
        status: "enum[active,resolved], optional"
      response:
        success:
          status: 200
          body:
            items: "Alert[] array"

# ================================
# 15. Admin Permissions
# ================================
  admin_permissions:
    list:
      method: "GET"
      path: "/admin/permissions"
      authentication: "admin_required"
      response:
        success:
          status: 200
          body:
            items: "Permission[] array"

    create:
      method: "POST"
      path: "/admin/permissions"
      authentication: "admin_required"
      request:
        body:
          name: "string, required"
          resource: "string, required"
          action: "string, required"
      response:
        success:
          status: 201
          body: "Permission object"

    update:
      method: "PATCH"
      path: "/admin/permissions/{id}"
      authentication: "admin_required"
      path_params:
        id: "uuid, required"
      request:
        body:
          name: "string, optional"
          description: "string, optional"
      response:
        success:
          status: 200

    delete:
      method: "DELETE"
      path: "/admin/permissions/{id}"
      authentication: "admin_required"
      path_params:
        id: "uuid, required"
      response:
        success:
          status: 204

# ================================
# 16. Admin Roles
# ================================
  admin_roles:
    list:
      method: "GET"
      path: "/admin/roles"
      authentication: "admin_required"
      response:
        success:
          status: 200
          body:
            items: "Role[] array"

    create:
      method: "POST"
      path: "/admin/roles"
      authentication: "admin_required"
      request:
        body:
          name: "string, required"
          permissions: "string[] array"
      response:
        success:
          status: 201
          body: "Role object"

    update:
      method: "PATCH"
      path: "/admin/roles/{id}"
      authentication: "admin_required"
      path_params:
        id: "uuid, required"
      request:
        body:
          name: "string, optional"
          permissions: "string[] array, optional"
      response:
        success:
          status: 200

    delete:
      method: "DELETE"
      path: "/admin/roles/{id}"
      authentication: "admin_required"
      path_params:
        id: "uuid, required"
      response:
        success:
          status: 204

    assign:
      method: "POST"
      path: "/admin/roles/{id}/assign"
      authentication: "admin_required"
      path_params:
        id: "uuid, role_id"
      request:
        body:
          user_id: "uuid, required"
      response:
        success:
          status: 200

# ================================
# 17. Response Standards
# ================================
response_format:
  success:
    structure:
      data: "Response data object or array"
      message: "Optional success message"
      timestamp: "ISO 8601 datetime"

  error:
    structure:
      error: "Error code (e.g., VALIDATION_ERROR)"
      message: "Human-readable error message"
      details: "Optional error details object"
      timestamp: "ISO 8601 datetime"

  pagination:
    structure:
      items: "Array of items"
      total: "Total count"
      page: "Current page"
      pages: "Total pages"
      limit: "Items per page"

# ================================
# 11. Authentication & Security
# ================================
security:
  authentication:
    type: "JWT + Cookie"
    cookie_config:
      access_token:
        httpOnly: true
        secure: true
        sameSite: "strict"
        maxAge: 1800  # 30 minutes

      refresh_token:
        httpOnly: true
        secure: true
        sameSite: "strict"
        maxAge: 604800  # 7 days

  rate_limiting:
    default: "100 requests per minute"
    auth_endpoints: "5 requests per minute"
    upload_endpoints: "10 requests per hour"

  cors:
    allowed_origins:
      - "http://localhost:3555"
      - "https://inknowing.com"
    allowed_methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]
    allowed_headers: ["Content-Type", "Authorization"]
    allow_credentials: true

# ================================
# Contract Validation Rules
# ================================
validation_rules:
  api:
    - id: "API001"
      rule: "All endpoints must return standard response format"
      severity: "ERROR"

    - id: "API002"
      rule: "Protected endpoints must validate authentication"
      severity: "ERROR"

    - id: "API003"
      rule: "Input data must be validated before processing"
      severity: "ERROR"

    - id: "API004"
      rule: "Errors must include appropriate HTTP status codes"
      severity: "ERROR"

    - id: "API005"
      rule: "Pagination must be implemented for list endpoints"
      severity: "WARNING"

  security:
    - id: "SEC001"
      rule: "Passwords must be hashed with bcrypt"
      severity: "ERROR"

    - id: "SEC002"
      rule: "JWT tokens must expire"
      severity: "ERROR"

    - id: "SEC003"
      rule: "Rate limiting must be enforced"
      severity: "WARNING"

    - id: "SEC004"
      rule: "CORS must be properly configured"
      severity: "ERROR"